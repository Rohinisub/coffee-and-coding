---
title: "NHS England Recruitment Analysis"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    theme: cerulean
    css: styles.css
    
---

```{r setup, include=FALSE}
library(readxl)
library(stringr)
library(tm)
library(text2vec)
library(tidytext)
library(tidyr)
library(broom)
library(ggplot2)
library(forecast)
library(tseries)
library(data.table)
library(gridExtra)
library(plotly)
library(sqldf)
library(dplyr)
library(gridExtra)
library(tseries)
library(SnowballC)
library(wordcloud)
library(lubridate)
library(prophet)
library(rpivotTable)
library(caret)
library(randomForest)


```
```{r global, include=FALSE}
#Load data in global chunk
trac <- read_excel("F:/Information Services/DALL/DALL Initiatives CRISP-DM/INT #361 HRSS Exploratory MI/R Code V2/Data/Copy of full vacancies 04 06 18.xlsx")

nhs_jobs <- read_excel("F:/Information Services/DALL/DALL Initiatives CRISP-DM/INT #361 HRSS Exploratory MI/R Code V2/Data/NHS Job download - last 12 months NHSE on 04.12.17.xlsx")

ESR_changes <- read_excel("F:/Information Services/DALL/DALL Initiatives CRISP-DM/INT #361 HRSS Exploratory MI/R Code V2/Data/ESR all .xlsx", sheet = "change")
ESR_Hire <- read_excel("F:/Information Services/DALL/DALL Initiatives CRISP-DM/INT #361 HRSS Exploratory MI/R Code V2/Data/ESR all .xlsx", sheet = "Hire")
ESR_leavers <- read_excel("F:/Information Services/DALL/DALL Initiatives CRISP-DM/INT #361 HRSS Exploratory MI/R Code V2/Data/ESR all .xlsx", sheet = "leaver")
  
# Sort out the spacing issues in the column names
col_df <- colnames(nhs_jobs)
col_df <- gsub(" ", "_", col_df)
col_df <- gsub("/", "", col_df)
colnames(nhs_jobs) <- col_df

# Get rid of Noise Applications
#trac <- trac %>% filter(`Noise Y/N` == 'N')
org2 <- 'NHSE'
trac <- sqldf("select * from trac where departmentid like 'NHSE%'")

# Selct the columns you need for the trac data
trac <- sqldf("select vacancyid,
              jobsnhsid,
              departmentid,
              empjobref,
              esrempjobref,
              jobtitle,
              grade,
              mingradeid,
              maxgradeid,
              longadvert,
              locationtown,
              locationpostcode,
              site,
              contacttype,
              closingdate,
              closingtime,
              openclosingdate,
              startdate,
              nnprivateuse,
              urlstring,
              esrvacancyid,
              vacstage,
              vacstate,
              posnos,
              createddatetime,
              quantity from trac")

# Filter the columns on NHS jobs
nhs_jobs <- sqldf ("select Vacancy_ID,
                   Organisation_ID,
                   Vacancy_Reference_number,
                   Organisation_name,
                   Job_Title,
                   Location,
                   DivDept_for_Reporting,
                   Post_code,
                   Salary,
                   Pay_Scheme,
                   Pay_BandScale,
                   WTE,
                   Job_Type,
                   DBS_Check_required_indicated,
                   Fixed_term_contract_length,
                   Welsh_advert_exists,
                   Number_of_applications_submitted,
                   Create_date,
                   Published_date,
                   Advert_closed_date,
                   Date_of_first_interview,
                   Staff_Group,
                   Area_of_Work,
                   Occupation_Code,
                   SpecialtyFunction,
                   Department,
                   Cost_centre,
                   Application_ID,
                   Application_Reference_number,
                   Current_application_status,
                   NHS_Professional_returning_to_practice,
                   Age_at_application,
                   Age_band,
                   Gender,
                   Marital_Status,
                   Ethnic_Origin,
                   Sexual_Orientation,
                   Disability,
                   Number_of_views_of_advert,
                   Applicant_appointed,
                   Application_invited_to_interview,
                   Application_shortlisted
                   from nhs_jobs")

# Clean the trac data
trac$departmentid <- gsub(org2,"", trac$departmentid)
trac$mingradeid <- gsub("NHS AfC: ","", trac$mingradeid)    
trac$locationpostcode <- gsub(" ", "", trac$locationpostcode, fixed = TRUE)
trac$locationpostcode <- toupper(trac$locationpostcode)
trac$createddatetime <- as.Date(as.POSIXct(trac$createddatetime, 'GMT'))
trac$yrmon <- format(as.Date(trac$createddatetime), "%Y-%m")
trac$day <- weekdays(as.Date(trac$createddatetime))

# Clean data NHSJOBS
nhs_jobs$Pay_BandScale[nhs_jobs$Pay_BandScale=="Agenda for change - 2"]= "2"
nhs_jobs$Pay_BandScale[nhs_jobs$Pay_BandScale=="Agenda for change - 3"]= "3"
nhs_jobs$Pay_BandScale[nhs_jobs$Pay_BandScale=="Agenda for change - 4"]= "4"
nhs_jobs$Pay_BandScale[nhs_jobs$Pay_BandScale=="Agenda for change - 5"]= "5"
nhs_jobs$Pay_BandScale[nhs_jobs$Pay_BandScale=="Agenda for change - 6"]= "6"
nhs_jobs$Pay_BandScale[nhs_jobs$Pay_BandScale=="Agenda for change - 7"]= "7"
nhs_jobs$Pay_BandScale[nhs_jobs$Pay_BandScale=="Agenda for change - 8a"]= "8A"
nhs_jobs$Pay_BandScale[nhs_jobs$Pay_BandScale=="Agenda for change - 8b"]= "8B"
nhs_jobs$Pay_BandScale[nhs_jobs$Pay_BandScale=="Agenda for change - 8c"]= "8C"
nhs_jobs$Pay_BandScale[nhs_jobs$Pay_BandScale=="Agenda for change - 8d"]= "8D"
nhs_jobs$Pay_BandScale[nhs_jobs$Pay_BandScale=="Agenda for change - 9"]= "9"
nhs_jobs$Pay_BandScale[nhs_jobs$Pay_BandScale=="VSM (Very Senior Manager)"]= "VSM"
nhs_jobs$Pay_BandScale[nhs_jobs$Pay_BandScale=="Hospital Medical and Dental Staff - Doctor - Other"]= "Other"

nhs_jobs$Age_band[nhs_jobs$Age_band== "Under 18"]= "<20"
nhs_jobs$Age_band[nhs_jobs$Age_band== "18 to 19"]= "<20"
nhs_jobs$Age_band[nhs_jobs$Age_band== "20 to 24"]= "20-29"
nhs_jobs$Age_band[nhs_jobs$Age_band== "25 to 29"]= "20-29"
nhs_jobs$Age_band[nhs_jobs$Age_band== "30 to 34"]= "30-39"
nhs_jobs$Age_band[nhs_jobs$Age_band== "35 to 39"]= "30-39"
nhs_jobs$Age_band[nhs_jobs$Age_band== "40 to 44"]= "40-49"
nhs_jobs$Age_band[nhs_jobs$Age_band== "45 to 49"]= "40-49"
nhs_jobs$Age_band[nhs_jobs$Age_band== "50 to 54"]= "50-59"
nhs_jobs$Age_band[nhs_jobs$Age_band== "55 to 59"]= "50-59"
nhs_jobs$Age_band[nhs_jobs$Age_band== "60 to 64"]= "60-69"
nhs_jobs$Age_band[nhs_jobs$Age_band== "65 to 69"]= "60-69"
nhs_jobs$Age_band[nhs_jobs$Age_band== "65 to 69"]= "60-69"
nhs_jobs$Age_band[nhs_jobs$Age_band== "Missing"]= "Unknown"
nhs_jobs$Age_band[nhs_jobs$Age_band== "Undisclosed"]= "Unknown"

ESR_changes <- ESR_changes %>% filter(org == "990")
ESR_Hire <- ESR_Hire %>% filter(Organisation == "990")
ESR_leavers <- ESR_leavers %>% filter(organisation == "990")

# Join Trac and NHS Jobs together
# Inner join
full_df <- sqldf("select t.*, j.* from trac t 
                 inner join nhs_jobs j on t.esrempjobref = j.Vacancy_Reference_number")

####Prediction Model######
applicant2 <- sqldf("select distinct empjobref,
                    Pay_BandScale,
                    yrmon,
                    Job_Type,
                    Number_of_applications_submitted,
                    locationtown,
                   locationpostcode,
                   DivDept_for_Reporting
                    from full_df")

applicant2$locationtown[applicant2$locationtown=="London or Leeds"]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="Leeds / London"]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="Leeds/ London"]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="Skipton House, London or Quarry House, Leeds"]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="Leeds or London"]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="Leeds/London"]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="London / Leeds"]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="Quarry House, Leeds or Skipton House, London"]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="London, Leeds"]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="Leeds London"]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="London/Leeds - Flexible"]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="London or Leeds - Flexible"]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="Quarry House, Leeds OR Skipton House London."]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="Skipton House, London or Quarry House, Leeds"]= "London/Leeds"
applicant2$locationtown[applicant2$locationtown=="Leeds, Quarry House"]= "Leeds"
applicant2$locationtown[applicant2$locationtown=="Leeds, West Yorkshire"]= "Leeds"
applicant2$locationtown[applicant2$locationtown=="London Skipton House"]= "London"
applicant2$locationtown[applicant2$locationtown=="London - Skipton House"]= "London"
applicant2$locationtown[applicant2$locationtown=="Inner London"]= "London"
applicant2$locationtown[applicant2$locationtown=="London (Skipton House)"]= "London"
applicant2$locationtown[applicant2$locationtown=="Stephenson House, London"]= "London"
applicant2$locationtown[applicant2$locationtown=="Skipton House London"]= "London"
applicant2$locationtown[applicant2$locationtown=="Fulbourn, Cambridge"]= "Cambridge"
applicant2$locationtown[applicant2$locationtown=="Fulbourn, near Cambridge"]= "Cambridge"
applicant2$locationtown[applicant2$locationtown=="Fulbourn, Cambridgeshire"]= "Cambridge"
applicant2$locationtown[applicant2$locationtown=="Fulbourn"]= "Cambridge"
applicant2$locationtown[applicant2$locationtown=="Fulbourn,Cambridge"]= "Cambridge"
applicant2$locationtown[applicant2$locationtown=="Newcastle upon Tyne"]= "Newcastle"
applicant2$locationtown[applicant2$locationtown=="Newcastle, with travel around the area"]= "Newcastle"
applicant2$locationtown[applicant2$locationtown=="Newburn, Newcastle upon Tyne"]= "Newcastle"
applicant2$locationtown[applicant2$locationtown=="Newcastle-upon-Tyne"]= "Newcastle"
applicant2$locationtown[applicant2$locationtown=="Newcastle Upon Tyne"]= "Newcastle"
applicant2$locationtown[applicant2$locationtown=="Birmingham - St Chads"]= "Birmingham"
applicant2$locationtown[applicant2$locationtown=="Birmingham St Chads, Leicester Fosse House or Rugeley Anglesey House"]= "Birmingham"
applicant2$locationtown[applicant2$locationtown=="BIRMINGHAM"]= "Birmingham"

otherplaces <- applicant2 %>% dplyr::group_by(locationtown) %>% 
  dplyr::summarise(n = n(), avapps = mean(Number_of_applications_submitted))%>% 
  filter(n < 10) %>% select(locationtown) %>% pull

applicant2 %>% 
  mutate(locationtown = 
           ifelse(locationtown %in% otherplaces,"other", locationtown)) -> applicant2

applicant2 %>% 
  dplyr::group_by(locationtown) %>% 
  summarise(n = n_distinct(DivDept_for_Reporting)) %>% 
  filter(n>1) %>% arrange(desc(n))

data = applicant2 %>% select(Pay_BandScale, Job_Type, Number_of_applications_submitted, locationtown)

colnames(data) = c('band','job_type','n_apps','loc')

data = data %>% mutate_if(is.character, as.factor)

data$band = factor(data$band, ordered = TRUE)

## fit a random forest!
 
x = data %>% select(-n_apps) %>% mutate(band = as.numeric(band))
y = data %>% select(n_apps)

train_ids = sample(1:nrow(x), 0.8*nrow(x))

xtrain = x[train_ids,]
ytrain = y[train_ids,]

xtest = x[-train_ids,]
ytest = y[-train_ids,]


model = train(xtrain, ytrain, method = "rf")
preds = predict(model, x)


#mape <- function(y, yhat)
#  mean(abs((y - yhat)/y))

#mape(ytest, preds) ## 0.89 which means that the average prediction is almost 90% away from the true value...!

results = data.frame(y, preds, x)
results %>% 
  mutate(residual = abs(preds - ytest)) %>% 
  group_by(loc) %>% summarise(r = mean(residual)
                              , n = n()) %>%
  filter(n > 10) %>%
  arrange(desc(r))



jobs_df = expand.grid(unique(x$band), unique(x$job_type), unique(x$loc))
names(jobs_df) = names(x)

jobs_df = cbind(jobs_df, "pred" = predict(model, jobs_df))

t = factor(jobs_df$band) 
levels(t) = levels(data$band)

jobs_df = cbind(jobs_df, t) 

```

Introduction
======================================================================

column {.tabset}
----------------------------------------------------------------------

<div class = "image"> 
<img src = "F:/Information Services/Management Information Team/40. Matt/NHS_England_logo.png">
</div>

1 This report contains Recruitment Analysis for NHS England. It is based on the data held by NHS Business Services Authority on the Trac, NHS Jobs and ESR systems. It is for the time period January 2017 to October 2017

2 Trac is the main system used for the recruitment process  The data fields are free type and therefore there is a great variation in the way data has been entered. There is one row of data per job advertised in Trac 

3 NHS Jobs is not used for every job which is advertised.  The data fields have drop down menus therefore the data is more consistent and easier to analyse. It contains a row per application for the jobs and therefore allows anaylsis of age and gender of applicants

4 The two data sets can be joined together using the Vacancy Reference number in NHSJOBS and the EMPJOBREF from TRAC.  There were 2,138 jobs adverts and  1,822 distinct jobs could be matched in this data set.

5 Data from ESR provides information on leavers, people hired in to the organisation and changes of role within an organisation.

6 All data was supplied to us by HR shared services and extracted from their systems on the 15th December 2017. 

7 The data covered in this report are for jobs advertised from January 2017 to October 2017 on the TRAC and or NHSJob systems. 


Trend Over Time 
======================================================================

Row
----------------------------------------------------------------------

### Recruitments Over Time 
Number of recruitment campaigns per day From January 2017 to October 2017 (Data from ESR)  

```{r recruit_over_time}
rec_by_day <- trac %>%
              group_by(createddatetime)%>%
              summarise(num_rec = n(),
                        d_num_rec = n_distinct(esrempjobref))


dates_fill <- as.data.frame(seq(as.Date("2016/12/01"), as.Date("2017/12/01"), "days"))
colnames(dates_fill)[1]<-"c_date"

rec_vals <- sqldf("select d.c_date, r.num_rec, d_num_rec from dates_fill d
                   left outer join rec_by_day r on d.c_date = r.createddatetime")

rec_vals[is.na(rec_vals)] <- 0



# Graph Recruitments over time
p_rec_val <- plot_ly(rec_vals, 
             x =~c_date, y =~num_rec, type = 'scatter',  mode = 'lines') %>%
                layout(title = "Number of recruitment campaigns",
                xaxis = list(title = "Time"),
                yaxis = list (title = "Number of recruitments"))

p_rec_val
```

### Changes Over Time
Number of changes  per day From January 2017 to October 2017 (Data from ESR) 
```{r change_over_time}
# Need to do similar with leavers, changes, hires
colnames(ESR_changes)[1] <- "change_date"
ESR_changes$change_date <- as.Date(ESR_changes$change_date)

num_changes <- ESR_changes %>%
               group_by(change_date) %>%
               summarise(num_changes = n())

chang_vals <- sqldf("select d.c_date, r.num_changes from dates_fill d
                   left outer join num_changes r on d.c_date = r.change_date")

chang_vals[is.na(chang_vals)] <- 0

# Graph Changes over time
p_ch_val <- plot_ly(chang_vals, 
            x =~c_date, y =~num_changes, type = 'scatter',  mode = 'lines') %>%
            layout(title = "Number of changes over time",
             xaxis = list(title = "Time"),
             yaxis = list (title = "Number of changes"))

p_ch_val
```

Row
----------------------------------------------------------------

### Hires Over Time
Number of staff starting per day From January 2017 to October 2017 (Data from ESR) 
```{r hire_over_time}
#ESR Hire
colnames(ESR_Hire)[18] <- "start_date"
ESR_Hire$start_date <- as.Date(ESR_Hire$start_date)

num_hires <- ESR_Hire %>%
                group_by(start_date) %>%
                summarise(num_hires = n())

hire_vals <- sqldf("select d.c_date, r.num_hires from dates_fill d
                    left outer join num_hires r on d.c_date = r.start_date")

hire_vals[is.na(hire_vals)] <- 0

#Graph  hire over time

p_hire_val <- plot_ly(hire_vals, 
              x =~c_date, y =~num_hires, type = 'scatter',  mode = 'lines') %>%
              layout(title = "Number of Hires over time",
               xaxis = list(title = "Time"),
               yaxis = list (title = "Number of Starters"))

p_hire_val
```

### Leavers Over Time
Number of staff leaving per day From January 2017 to October 2017 (Data from ESR) 

```{r leave_over_time}
#Leavers
colnames(ESR_leavers)[15] <- "notified_date"
ESR_leavers$notified_date <- as.Date(ESR_leavers$notified_date)

num_leavers <- ESR_leavers %>%
                group_by(notified_date) %>%
                summarise(num_leavers = n())

leaver_vals <- sqldf("select d.c_date, r.num_leavers from dates_fill d
                   left outer join num_leavers r on d.c_date = r.notified_date")

leaver_vals[is.na(leaver_vals)] <- 0

# Graph Leavers over time
p_leav_val <- plot_ly(leaver_vals, 
            x =~c_date, y =~num_leavers, type = 'scatter',  mode = 'lines') %>%
               layout(title = "Number of Leavers over time",
               xaxis = list(title = "Time"),
               yaxis = list (title = "Number of Leavers"))

p_leav_val

#subplot(p_rec_val, p_ch_val, p_hire_val, p_leav_val, nrows = 2)
```


Forecast 
======================================================================

Row 
----------------------------------------------------------------

### Forecasted Recruitment Campaigns (Per Week) 

```{r Forecast_time, results = "hide"}
#Leavers
#ESR_leavers <- read_excel("./Data/ESR all .xlsx", sheet = "leaver")
#colnames(ESR_leavers)[15] <- "notified_date"
#ESR_leavers$notified_date <- as.Date(ESR_leavers$notified_date)
#is.na(ESR_leavers$organisation) <- "0"
#ESR_leavers <- ESR_leavers %>%
#  filter(organisation == "990")


dates_fill <- as.data.frame(seq(as.Date("2016/12/14"), as.Date("2018/06/04"), "days"))
colnames(dates_fill)[1]<-"c_date"



##########################################################
# Forecastng Analysis
##########################################################
# Recruitment analysis - Num campaigns
rec_by_day <- trac %>%
  group_by(createddatetime)%>%
  summarise(num_rec = n(),
            d_num_rec = n_distinct(empjobref))

rec_vals <- sqldf("select d.c_date, r.num_rec, d_num_rec from dates_fill d
                  left outer join rec_by_day r on d.c_date = r.createddatetime")
rec_vals[is.na(rec_vals)] <- 0

# Number of leavers
num_leavers <- ESR_leavers %>%
  group_by(notified_date) %>%
  summarise(num_leavers = n())

leaver_vals <- sqldf("select d.c_date, r.num_leavers from dates_fill d
                     left outer join num_leavers r on d.c_date = r.notified_date")

leaver_vals[is.na(leaver_vals)] <- 0

####################################
#Week forcast#
#################################

  weeks <- rec_vals[,c(1,2)]
  colnames(weeks) <- c("ds","y")
  weeks$week_date <- floor_date(as.Date(weeks$ds), unit="week")
  agg_week <- aggregate(weeks$y, 
                             by=list(weeks$week_date), FUN=sum)
agg_week <- agg_week[17:73,]
colnames(agg_week) <-c("ds", "y")

leaver_vals2 <- leaver_vals
leaver_vals2$leave_date <- floor_date(as.Date(leaver_vals2$c_date), unit = "week")
agg_leaver <- aggregate(leaver_vals2$num_leavers, 
             by=list(leaver_vals2$leave_date), FUN=sum, na.rm = TRUE)
colnames(agg_leaver) <-c("ds", "y")

agg_week2 <- merge(x=agg_week, y=agg_leaver, by=("ds"), all.x=TRUE)
colnames (agg_week2) <-c("ds","y","regressor")

#########
#Prophet#
##########
agg_week <- agg_week[17:73,]
#m$extra_regressors <- agg_week2$regressor
m <- prophet(agg_week, yearly.seasonality = TRUE)
#m$extra_regressors <- agg_week2$regressor
m



future <- make_future_dataframe(m,freq = "week", periods = 52)
forecast <- predict(m, future)


plot(m, forecast,
     xlabel = "Time", ylabel = "Number of Recruitment Campaigns")

###########
# Arima##
##########
##Daily Model##

# Make the recruitment count a time series
count_fts = ts(rec_vals[, c('num_rec')])

# Clean the data - missing values/ estimates etc
rec_vals$clean_cnt = tsclean(count_fts)
#
ggplot() +
  geom_line(data = rec_vals, aes(x = c_date, y = num_rec)) + 
  #geom_line(data = dft2, aes(x = startdate, y = count, colour = "Original"))
  ylab('Cleaned recruitment Count')

# Weekly moving average
rec_vals$cnt_ma = ma(rec_vals$clean_cnt, order = 7) 

# using the clean count with no outliers
# Monthly moving average
rec_vals$cnt_ma30 = ma(rec_vals$clean_cnt, order = 30)

ggplot() +
  geom_line(data = rec_vals, aes(x = c_date, y = clean_cnt, colour = "Counts")) +
  geom_line(data = rec_vals, aes(x = c_date, y = cnt_ma,   colour = "Weekly Moving Average"))  +
  geom_line(data = rec_vals, aes(x = c_date, y = cnt_ma30, colour = "Monthly Moving Average"))  +
  ylab('Recruitment Count')

 #Check for any seasonality
count_ma = ts(na.omit(rec_vals$clean_cnt))
plot(count_ma)
#decomp = stl(count_ma, s.window="periodic")
#plot(decomp)

# Check it's stationary and appropriate from ARIMA
adf.test(count_ma, alternative = "stationary")
par(mfrow = c(1,2))
Acf(count_ma, main='')
Pacf(count_ma, main='')

ARIMAfit = auto.arima(count_ma, approximation=FALSE,trace=FALSE)
summary(ARIMAfit)

f <- arima(count_ma, c(4,1,2))
tsdisplay(residuals(f), lag.max=45, main='ARIMA(4,1,2) Model Residuals')

fcast <- forecast(f,h = 52)
plot(fcast, main=" ")

##Weekly Model##
# Make the recruitment count a time series
count_fts = ts(agg_week[, c('x')])

# Clean the data - missing values/ estimates etc
agg_week$clean_cnt = tsclean(count_fts)
#
ggplot() +
  geom_line(data = agg_week, aes(x = Group.1, y =' x')) + 
  #geom_line(data = dft2, aes(x = startdate, y = count, colour = "Original"))
  ylab('Cleaned recruitment Count')

# Weekly moving average
agg_week$cnt_ma = ma(agg_week$clean_cnt, order = 7) 

# using the clean count with no outliers
# Monthly moving average
agg_week$cnt_ma30 = ma(agg_week$clean_cnt, order = 30)

ggplot() +
  geom_line(data = agg_week, aes(x = Group.1, y = clean_cnt, colour = "Counts")) +
  geom_line(data = agg_week, aes(x = Group.1, y = cnt_ma,   colour = "Weekly Moving Average"))  +
  geom_line(data = agg_week, aes(x = Group.1, y = cnt_ma30, colour = "Monthly Moving Average"))  +
  ylab('Recruitment Count')

 #Check for any seasonality
count_ma = ts(na.omit(agg_week$clean_cnt))
plot(count_ma)
#decomp = stl(count_ma, s.window="periodic")
#plot(decomp)

# Check it's stationary and appropriate from ARIMA
adf.test(count_ma, alternative = "stationary")
par(mfrow = c(1,2))
Acf(count_ma, main='')
Pacf(count_ma, main='')

ARIMAfit = auto.arima(count_ma, approximation=FALSE,trace=FALSE)
summary(ARIMAfit)

f <- arima(count_ma, c(4,1,2))
tsdisplay(residuals(f), lag.max=45, main='ARIMA(4,1,2) Model Residuals')

fcast <- forecast(f,h = 52)
plot(fcast, main=" ")

# Take the seasonality out of the model
#deseasonal_cnt <- seasadj(decomp)
#plot(deseasonal_cnt)

# Create the residuals
n_leav <- ts(leaver_vals[, c('num_leavers')])
n_hire <- ts(hire_vals[, c('num_hires')])
n_chan <- ts(chang_vals[, c('num_changes')])
x1 <- cbind(n_leav, n_hire)
x1 <- cbind(x1, n_chan)

# Auto ARIMA summary
ARIMAfit = auto.arima(count_ma, approximation=FALSE,trace=FALSE, xreg=x1)
summary(ARIMAfit)

f <- arima(count_ma, c(4,1,2), xreg=x1)
tsdisplay(residuals(f), lag.max=45, main='ARIMA(4,1,2) Model Residuals')

#f2 <- auto.arima(train, approximation=FALSE, trace=FALSE, xreg=trainleaver)
fcast <- forecast(f,h = 3, xreg=x1)
plot(fcast, main=" ")

```

>The forecast is based on data from January 2017 to October 2017 and forecasts the following 6 months of data.

Application prediction
======================================================================

Row
----------------------------------------------------------------

### Prediction of number of application per advertising campaign by Job Grade, Location and Job Type. 
The data can be filtered using the Location tab, the Job_Type tab and the Job role tab, to find the predicted number of application the will be received for the advertised post. (The prediction model is based on Data from Trac from January 2017 to October 2017)

```{r predict}
piv_dat <- sqldf("select job_type, loc, t, pred from jobs_df")
colnames (piv_dat) <- c("Job_Type", "Location", "Band", "Prediction")
rpivotTable(piv_dat,rows =c("Location", "Job_Type"), 
            cols= "Band", vals = "Prediction",
            aggregatorName = "Average", 
            rendererName = "Table", width="100%", height="500px")
```


Application Analysis {.storyboard data-navmenu="Analysis"}
=====================================================================

### Job Adverts per month, January 2017 to October 2017 


```{r number_per_month}
# Job adverts per month
num_jobs_month <- full_df %>% group_by(yrmon) %>%
  dplyr::summarise(num_camp = n_distinct(empjobref))
num_jobs_month <- filter(num_jobs_month, yrmon != "2017-11")

#graph Job adverts per month
Jobs_month <- plot_ly(num_jobs_month, x= ~num_jobs_month$yrmon, y= ~num_jobs_month$num_camp, type = 'scatter', mode = 'lines')%>%
layout(title = "Job Adverts per Month, January 2017 to October 2017",
       margin = list(r = 50),
       xaxis = list(title = "Month"),
       yaxis = list (title = "Number of applications"))
Jobs_month
```

***

The lowest number of recruitment campaigns is in January and the highest 2 months are March and August 2017. On average there are 194 recruitment campaigns per month.

(Graph is based on information from the combined Trac and NHS Jobs data)

### Jobs that need to be readvertised more than once

```{r re_advertising jobs}
#proportion of repeat jobs                
no_ads_grade <- full_df %>% 
                  group_by(Job_Type, Pay_BandScale) %>% 
                  dplyr::summarise(num_adverts = n_distinct(empjobref)) 
      
agg_ads_grade <- aggregate(no_ads_grade$num_adverts, by=list(no_ads_grade$Pay_BandScale, no_ads_grade$Job_Type), FUN=sum, na.rm=TRUE)

colnames(agg_ads_grade) <- c("Grade", "Job_Type", "Total")


#job adverts more than once on full data
numagr <- full_df%>% group_by(esrempjobref, Pay_BandScale, Job_Type)%>% 
          dplyr::summarise(num_adverts = n_distinct(empjobref))%>%
          filter(num_adverts >1)

#number of jobs advertised more than once
agg_numjobs <- aggregate(numagr$num_adverts, by=list(numagr$Pay_BandScale, numagr$Job_Type), 
                  FUN=sum, na.rm=TRUE)
colnames(agg_numjobs) <- c("Grade", "Job_Type", "TRepeat")
#proportions

agg_ads_grade <- merge(x=agg_ads_grade, y=agg_numjobs, by=c("Grade","Job_Type"), all.x=TRUE)
agg_ads_grade$prop <- round((agg_ads_grade$TRepeat/agg_ads_grade$Total)*100,2)
agg_ads_grade <-sqldf('SELECT *
              FROM agg_ads_grade
              WHERE Job_Type IN ("Fixed term", "Permanent" )')                    


agg_ads_grade <-agg_ads_grade %>% filter(!is.na(TRepeat)) # Gets rid of any lines with NA in it (assuming its in both TRepeat and prop )

# graph repeat adverts
agg_ads_grade_plot <- agg_ads_grade
agg_ads_grade_plot$Grade <- factor(agg_ads_grade_plot$Grade, levels = unique(agg_ads_grade_plot$Grade))

plot_ly(agg_ads_grade_plot, x = ~Grade, y = ~prop, color = ~Job_Type, type = 'bar') %>%
  layout(title = "Jobs that Needed to be Advertised More than Once",
         xaxis = list(title = "Job Grade"),
         yaxis = list(title = "Proportion of Jobs (%)"))

```

***

The graph shows the  percentage of jobs at each grade that need to be advertised more than once, and compares the rate for fixed term jobs compared to Permanent jobs. It can be seen that fixed term jobs at higher grades need to be re-advertised more often than permanent jobs. 

(Graph is based on the combined information from Trac and NHS Jobs data for jobs advertised Between January 2017 to October 2017)


### Average number of times a job advert was viewed per application received


```{r number_views_per_application}
# Number of applications per grade nhs jobs

nhs_apb <- nhs_jobs %>% group_by (Pay_BandScale, Job_Type, Number_of_views_of_advert)%>% 
  dplyr::summarise(num_apps =n())


# Number of applications per band
nhs_apb_a <- nhs_apb %>%
  select(Number_of_views_of_advert, num_apps, Job_Type, Pay_BandScale) %>%
  group_by(Job_Type, Pay_BandScale) %>%
  dplyr::summarise(n_num_apps = sum(num_apps),
                   n_Number_Of_views = sum(Number_of_views_of_advert))
num_views_apb <- transform (nhs_apb_a, no_view = n_Number_Of_views / n_num_apps)

#Graph number of views per application
num_views_apb_plot <- num_views_apb
num_views_apb_plot$Pay_BandScale <- factor(num_views_apb_plot$Pay_BandScale, levels = unique(num_views_apb_plot$Pay_BandScale))
num_views_apb_plot$no_view <- round(num_views_apb_plot$no_view)

plot_ly(num_views_apb_plot, 
        x = ~Pay_BandScale, y = ~no_view, color = ~Job_Type,
        type = 'bar')%>%
          layout(title = "Average Number of Views per Application Recieved by Job Grade",
       xaxis = list(title = "Job Grade"),
       yaxis = list (title = "Average Number of Applications per View"))
```


***

The graph shows the average number of times a job was viewed per application received. This information is taken from the NHS Jobs data. It can be seen that there are more views per application received for the Secondment and Fixed term jobs. There is also a trend that the higher band jobs have more views per application received.  Further analysis on the job type and location of the post could be carried out on the jobs that have the most views per application if this is an area of interest.

(The graph is based on the data from the combined Trac and NHS jobs data Between January 2017 to October 2017)

### Average number of applications per pay band by gender

```{r gender_applications}

# Number Applicantion/ gender
nhs_jobs_gender <- nhs_jobs %>% group_by(Pay_BandScale, Vacancy_Reference_number, Gender) %>% dplyr::summarise(num_apps = n())
nhs_job_gen_a <- nhs_jobs_gender %>% group_by(Pay_BandScale, Gender) %>% 
  dplyr::summarise (avg_num_apps = mean(num_apps),
                   max_num = max(num_apps),
                   min_num = min(num_apps),
                   tot_num_apps = sum(num_apps))

# Graph number of application by gender
plot_ly(nhs_job_gen_a, 
        x =~Pay_BandScale, y =~avg_num_apps, color = ~Gender, type = 'bar')%>%
          layout(title = "Average Number of Applications per Job Grade by Gender",
       xaxis = list(title = "Job Grade"),
       yaxis = list (title = "Average Number of Job Applications"))
```

***

The graph shows the average number of applications per pay band by gender. It can be seen at the lower pay bands significantly more females apply to males, at band 8B it is an even split. Above an band 8B there are more male than female applications. Graph 4 also shows the average number of applications decrease considerably for women as the pay band increases, but is more even across the pay bands for men. There is a small number at all bands where gender wasn't disclosed.

(The graph is based on data from NHS Jobs for applications for jobs advertised between January 2017 and October 2017)

### Average number of applications per pay band by age

```{r age_applications}
# Number Applications/ age band
nhs_job_age <- nhs_jobs %>% group_by(Pay_BandScale, Vacancy_Reference_number, Age_band) %>% dplyr::summarise(num_apps = n())

nhs_job_age_a <- nhs_job_age %>% group_by(Pay_BandScale, Age_band)%>%
   dplyr::summarise (avg_num_apps = mean(num_apps),
                   max_num = max(num_apps),
                   min_num = min(num_apps),
                   tot_num_apps = sum(num_apps)) 

#Graph number of applications by ages
plot_ly(nhs_job_age_a, 
        x =~Pay_BandScale, y =~avg_num_apps, color = ~Age_band, type = 'bar')%>%
          layout(title = "Average Number of Applications per Job Grade by age band",
       xaxis = list(title = "Job Grade"),
       yaxis = list (title = "Average Number of Job Applications"))


```


*** 
The graph shows the average number of applications per Job Grade based on ages ranges. As the pay band increases the age of the applicant increase. This is to be expected as there is likely to be more experience required at the higher grade jobs. Applicants aged between 20-29 are most likely to apply for Job grade 3 to 5. Age group 50-59 are most likely to apply for a band 9 job.

(The graph is based on data from NHS Jobs for applications for jobs advertised between January 2017 and October 2017)

### Average number of applicants with a Declared Disability

```{r disability}
#NHSJOBS Disability
NHS_disp <- sqldf ("select Vacancy_Reference_number,
                        Pay_BandScale,
                        Gender,
                        Disability
                        from nhs_jobs where Disability = 'Yes'")

NHS_disp$Disability[NHS_disp$Disability=="Yes"]="1"
NHS_disp[,4] <- as.numeric(as.character(NHS_disp[,4]))

NHS_disp_ag <- NHS_disp %>% group_by(Pay_BandScale, Vacancy_Reference_number) %>% dplyr::summarise(Disability = n())
NHS_disp_avg  <-  NHS_disp_ag %>% group_by(Pay_BandScale)%>%
   dplyr::summarise (avg_num_apps = mean(Disability),
                   max_num = max(Disability),
                   min_num = min(Disability),
                   tot_num_apps = sum(Disability)) 
#disability graph

plot_ly(NHS_disp_avg, 
        x =~Pay_BandScale, y =~avg_num_apps, type = 'bar')%>%
          layout(title = "Average Number of Applications per Job Grade by applicants who declaire a Disability",
       xaxis = list(title = "Job Grade"),
       yaxis = list (title = "Average Number of Job Applications"))


```


***
The graph shows that there is a higher rate of people with a disability apply for band 2 and 3 jobs. Of the higher grade jobs band 8c has the highest rate.  

(The graph is based on data from NHS Jobs for applications for jobs advertised between January 2017 and October 2017)

### Long advert polarity score by grade  

```{r pol_grade}
# Load Text data
advert_analysis <- read.csv("./Data/Advert_Text.csv")

# Graph the polarity against grade


plot_ly(advert_analysis, x = ~pol_score, color = ~Pay_BandScale, type = "box") %>% 
  layout(
  showlegend = FALSE,
  title = "Polarity score by Band",
  xaxis = list(title = "Long Advert Polarity Score"),
  margin = list(l = 250, r = 20, b = 80, t = 50, pad = 4))


```


***

Analysis of the words used in the text of the job adverts it shows that in the main there is little difference between the average polarity of the text used in the job adverts and are all slightly positive. However, when you look at the outlines in Graph 5 it shows that one particular job at Band 8b was the most negative of all job adverts.

(The graph is based on data from Trac for applications for jobs advertised between January 2017 to october 2017)


### Word cloud of the negative words in Job Adverts
The top negative words used in job adverts by NHS England between January 2017 and October 2017 


```{r word_cloud_Pos_text}
# Word cloud of most common negative words used in adverts
jeopCorpus <- Corpus(VectorSource(advert_analysis$neg_words))
jeopCorpus <- tm_map(jeopCorpus, stemDocument)

wordcloud(jeopCorpus,
scale=c(5,0.5), max.words=100, random.order=FALSE, 
rot.per=0.35, use.r.layout=FALSE, colors=brewer.pal(8,"Dark2"))

```

### Word cloud of positive words in Job Adverts
The top positive words used in job adverts by NHS England between January 2017 and October 2017 

```{r word_cloud_neg_text}
# Word cloud of most common positive words used in adverts
jeopCorpus2 <- Corpus(VectorSource(advert_analysis$pos_words))
jeopCorpus2 <- tm_map(jeopCorpus2, stemDocument)


wordcloud(jeopCorpus2,
          scale=c(5,0.5), max.words=100, random.order=FALSE, 
          rot.per=0.35, use.r.layout=FALSE, colors=brewer.pal(8,"Dark2"))
```




Appointment Analysis {.storyboard data-navmenu="Analysis"}
=====================================================================

### Gender of applicants appointed by Pay band

```{r Gender_appoint}
ESR_p <- read_excel("./Data/ESR pay.xlsx")
#ESR males and females employed.
ESR_gen <- sqldf("select Grade, Gender, count from ESR_p")
ESR_gen_agg <-ESR_gen%>% group_by(Grade, Gender)%>% dplyr::summarise(count = n())
ESR_gen_agg2 <- ESR_gen%>% group_by(Grade)%>% dplyr::summarise(count = n())
ESR_g_1 <- merge(x=ESR_gen_agg, y=ESR_gen_agg2, by=c("Grade"),all.x=TRUE)
colnames(ESR_g_1) <-c("Grade", "Gender", "Count", "Total")
ESR_g_1$prop <- round((ESR_g_1$Count/ESR_g_1$Total)*100,1)

#graph


plot_ly(ESR_g_1, 
        x =~Grade, y =~prop, color = ~Gender, type = 'bar')%>%
          layout(title = "Percentage of males and females per grade appointed",
       xaxis = list(title = "Job Grade"),
       yaxis = list (title = "Average Number of Job Applications"))




```


***
The graph shows that overall at all pay grades more females than males were employed. As the pay band increases the percentage of females to males decreases.

(The graph is based on data from ESR for appointments between January 2017 to october 2017)

### percentage of people who started above bottom Spine point

```{r spine point}
#ESR_Hire which spine people started.
ESR_p <- read_excel("./Data/ESR pay.xlsx")

ESR_pay <- sqldf("select Grade, Start, count from ESR_p")
ESR_pay_agg <-ESR_pay%>% group_by(Grade, Start)%>% dplyr::summarise(count = n())

ESR_pay_agg2 <- ESR_pay%>% group_by(Grade)%>% dplyr::summarise(count = n())

ESR_p_1 <- merge(x=ESR_pay_agg, y=ESR_pay_agg2, by=c("Grade"),all.x=TRUE)
colnames(ESR_p_1) <-c("Grade", "Start", "Count", "Total")
ESR_p_1$prop <- round((ESR_p_1$Count/ESR_p_1$Total)*100,1)
ESR_p_1$Start[ESR_p_1$Start=="N"]= "No"
ESR_p_1$Start[ESR_p_1$Start=="Y"]= "Yes"


plot_ly(ESR_p_1, 
        x =~Grade, y =~prop, color = ~Start, type = 'bar')%>%
          layout(title = "Percentage of people per grade who started on the bottom spine point of the pay band",
       xaxis = list(title = "Job Grade"),
       yaxis = list (title = "Average Number of Job Applications"))
```


***
The graph shows that all people starting as a band 2 in NHS England started on the bottom spine point of the band. As the Job Grade increases the percentage of people starting on the bottom spine point decreases. From Band 7 upwards over 50% of all people start at a higher spine point than the bottom of the scale. 

(The graph is based on data from ESR for appointments between January 2017 to october 2017)
